# CLAUDE.ru.md - Руководство для AI-ассистентов

## Обзор проекта

**Название проекта:** ai-agent-referendum
**Версия:** 1.0.0
**Назначение:** Telegram-бот агент для автоматизированного охвата кампаний с AI-ответами и контролем человека

Это Node.js приложение которое:
- Управляет исходящими Telegram-разговорами с лидами кампаний
- Использует GPT-4o-mini с RAG (Retrieval Augmented Generation) для контекстно-зависимых AI-ответов
- Предоставляет интерфейс контрольного бота для надзора администратора и одобрения сообщений
- Отслеживает статусы кампаний и прогресс лидов через Supabase
- Реализует индикаторы набора текста и естественные задержки для человекоподобного взаимодействия

---

## Структура кодовой базы

```
/home/user/Ai-agent/
├── index.js                       # Основная точка входа - слушатель событий и оркестрация
├── package.json                   # Зависимости и метаданные проекта
├── package-lock.json              # Зафиксированные версии зависимостей
├── .gitignore                     # Шаблоны игнорирования Git
│
├── src/
│   ├── config/
│   │   └── env.js                # Конфигурация окружения с валидацией Joi
│   │
│   ├── modules/                   # Модули основной функциональности
│   │   ├── auth.js              # Аутентификация Telegram-сессии
│   │   ├── db.js                # Клиент Supabase и данные агента
│   │   ├── send.js              # Отправка сообщений с задержками/набором
│   │   ├── aiAgent.js           # Генерация AI-ответов с RAG
│   │   └── controlBot.js        # Контрольный бот администратора для проверки сообщений
│   │
│   ├── services/                  # Сервисы бизнес-логики
│   │   ├── dialog.js            # Оркестрация диалогов
│   │   ├── dialogState.js       # Локальное JSON управление состоянием
│   │   └── campaignManager.js   # Управление кампаниями и лидами
│   │
│   └── utils/
│       └── logger.js            # Конфигурация логгера Winston
│
├── scripts/                       # Утилитарные скрипты
│   ├── addTestLead.js           # Создание тестовых данных кампании
│   └── embedKnowledge.js        # Эмбеддинг базы знаний для RAG
│
└── knowledge/
    └── referendum.txt           # Контент базы знаний

Генерируемые файлы (игнорируются git):
├── .env                         # Переменные окружения
├── app.log                      # Логи приложения
├── control_state.json           # Состояние контрольного бота
└── dialog_state.json            # Хранилище истории диалогов
```

---

## Технологический стек

| Технология | Версия | Назначение |
|------------|---------|---------|
| **Node.js** | ESM модули | Среда выполнения |
| **Telegram** | ^2.25.8 | Библиотека клиента Telegram API |
| **OpenAI** | ^4.57.0 | LLM API (GPT-4o-mini) |
| **Supabase** | ^2.45.4 | PostgreSQL + векторная БД для RAG |
| **Joi** | ^17.13.3 | Валидация схем |
| **Winston** | ^3.14.2 | Структурированное логирование |
| **dotenv** | ^16.4.5 | Конфигурация окружения |

**Система модулей:** ES Modules (`"type": "module"`)
**Архитектурный паттерн:** Событийно-управляемый с модульными сервисными слоями

---

## Ключевой поток приложения

### Последовательность запуска (index.js)

1. Загрузка и валидация переменных окружения
2. Инициализация Telegram-клиента с сессией агента из Supabase
3. Загрузка данных агента (промпты, персона, текст приветствия)
4. Запуск слушателя контрольного бота (интерфейс администратора)
5. Получение активных диалогов из базы данных
6. Проверка новых лидов и отправка приветственного сообщения при наличии
7. Начало прослушивания входящих Telegram-сообщений

### Поток обработки сообщений

```
Входящее сообщение → Пометить как прочитанное → Проверить статус передачи
                                                         ↓
                                                  Получить состояние диалога
                                                         ↓
                                              Сгенерировать AI-ответ (с RAG)
                                                         ↓
                                                Проверить намерение передачи
                                                         ↓
                    ┌────────────────────────────────────┴──────────────────────────────┐
                    ↓                                                                    ↓
            Нужна передача                                                      Прямой ответ
                    ↓                                                                    ↓
        Отправить в контрольный бот                                           Отправить пользователю
        Обновить статус: PENDING_HANDOVER                                     Обновить историю
        Обновить лид: HANDOVER                                                Обновить лид: REPLIED
```

### Поток контрольного бота

```
Администратор получает уведомление → Просмотр сообщения
                                              ↓
              ┌───────────────────────────────┼───────────────────────────┐
              ↓                               ↓                           ↓
          Одобрить                        Редактировать              Отклонить
              ↓                               ↓                           ↓
      Отправить пользователю          Изменить и отправить         Отбросить сообщение
      Сбросить статус                 Сбросить статус              Оставить PENDING
```

---

## Схема базы данных (Supabase)

### Таблица ai_agents
```javascript
{
  id: UUID,                      // Первичный ключ
  agent_name: string,            // Отображаемое имя
  tg_session_string: string,     // Сессия аутентификации Telegram
  initial_opener_text: string,   // Сообщение первого контакта
  client_id: UUID,               // Для фильтрации RAG
  core_system_prompt: string,    // Системные инструкции для AI
  agent_persona: string          // Определение характера агента
}
```

**Текущий UUID агента:** `8435c742-1f1e-4e72-a33b-2221985e9f83` (захардкожено в index.js:20)

### Таблица campaigns
```javascript
{
  id: UUID,
  client_id: UUID,
  name: string,
  status: 'ACTIVE' | 'PAUSED' | 'COMPLETED'
}
```

### Таблица leads
```javascript
{
  id: UUID,
  campaign_id: UUID,
  username: string,              // Telegram username (без @)
  channel_name: string,
  status: 'NEW' | 'CONTACTED' | 'REPLIED' | 'HANDOVER',
  assigned_agent_id: UUID,
  first_contact_at: timestamp,
  last_contact_at: timestamp,
  metadata: jsonb
}
```

### Таблица knowledge_base (RAG)
```javascript
{
  id: UUID,
  client_id: UUID,              // Для фильтрации по клиенту
  content: string,              // Текстовый фрагмент (~500 символов)
  embedding: vector(1536),      // OpenAI эмбеддинг
  source: string,               // Идентификатор исходного документа
  created_at: timestamp
}
```

**RPC-функция векторного поиска:**
```sql
match_knowledge(query_embedding, match_threshold, match_count, client_id)
```

### Локальные файлы состояния

**dialog_state.json** - История разговоров и статус
```javascript
{
  "{agent_id}_{username}": {
    history: [
      { role: 'user', content: '...' },
      { role: 'assistant', content: '...' }
    ],
    status: 'ACTIVE' | 'PENDING_HANDOVER' | 'NEW',
    pending_reply: string,        // Сообщение в ожидании одобрения
    targetUsername: string,
    lastUpdate: timestamp
  }
}
```

---

## Конфигурация окружения

### Необходимые переменные окружения (.env)

```bash
# Конфигурация Telegram-агента
TG_API_ID=<число>               # Из https://my.telegram.org
TG_API_HASH=<строка>            # Из https://my.telegram.org
TG_PHONE=<строка>               # Номер телефона агента
TG_SESSION=<строка>             # Опционально: существующая сессия

# Конфигурация OpenAI
OPENAI_API_KEY=<строка>         # API ключ OpenAI

# Конфигурация Supabase
SUPABASE_URL=<строка>           # URL проекта Supabase
SUPABASE_KEY=<строка>           # Сервисный ключ Supabase

# Контрольный бот (интерфейс администратора)
CONTROL_BOT_TOKEN=<строка>      # От @BotFather
CONTROL_SECRET_KEY=<строка>     # Секретный ключ безопасности
CONTROL_ADMIN_ID=<число>        # Telegram ID администратора
```

### Валидация

Все переменные окружения валидируются с помощью схемы Joi при запуске (src/config/env.js:8-26).
Приложение завершится с ошибкой, если валидация не пройдена.

### Захардкоженная конфигурация

- **UUID агента:** `8435c742-1f1e-4e72-a33b-2221985e9f83` (index.js:20)
- **Тестовая цель:** `@ilmanEl` (src/config/env.js:50)
- **AI модель:** `gpt-5-mini` (src/config/env.js:37) - Примечание: Похоже на опечатку, вероятно должно быть `gpt-4o-mini`
- **Ограничения скорости:** 1000-3000мс задержка ответа (src/config/env.js:51-54)

---

## Объяснение ключевых модулей

### 1. index.js (Главная точка входа)
**Строк:** 167
**Назначение:** Оркестрация приложения и обработка событий

**Ключевые обязанности:**
- Инициализация Telegram-клиента
- Загрузка данных агента из Supabase
- Запуск слушателя контрольного бота
- Обработка входящих событий сообщений
- Координация с AI-агентом и менеджером кампаний
- Управление рабочим процессом передачи

**Важные константы:**
- Строка 20: `CURRENT_AGENT_UUID` - Измените это для переключения агентов

### 2. src/modules/aiAgent.js (Генерация AI-ответов)
**Назначение:** Генерация AI-ответов с использованием GPT-4o-mini с RAG

**Ключевые функции:**
- `generateAIReply(history, agentData, openaiKey)` - Главная функция
- RAG: Получает релевантные знания из векторной БД Supabase
- Определение намерений: Определяет, нужна ли передача
- Возвращает: `{ agentReply, handoverIntent }`

**Намерения передачи:**
- `POSITIVE_CLOSE` - Пользователь готов продолжить (положительное вовлечение)
- `AI_FAILURE` - AI не может обработать запрос
- `null` - Продолжить обычный разговор

### 3. src/modules/controlBot.js (Интерфейс контроля администратора)
**Строк:** 203
**Назначение:** Telegram-бот для контроля человеком

**Ключевые функции:**
- `startControlBotListener(deps)` - Слушатель длинного опроса
- `sendHandoverNotification(data)` - Отправка сообщения на проверку
- Встроенная клавиатура с кнопками: Одобрить, Редактировать, Отклонить

**Управление состоянием:**
- Использует `control_state.json` для смещения опроса
- Интегрируется с `dialogState.js` для состояния разговора

### 4. src/services/campaignManager.js (Управление лидами)
**Назначение:** Отслеживание прогресса кампании и статуса лидов

**Ключевые функции:**
- `getActiveDialogs(agentId)` - Получение разговоров в процессе
- `getNextLead(agentId)` - Получение следующего НОВОГО лида для охвата
- `updateLeadStatus(campaignId, username, status)` - Обновление прогресса лида

**Прогрессия статусов:**
```
NEW → CONTACTED → REPLIED → HANDOVER
```

### 5. src/services/dialogState.js (Сохранение состояния)
**Назначение:** Локальное JSON-хранилище истории разговоров

**Ключевые функции:**
- `getDialogState(agentId, username)` - Получить разговор
- `updateDialogState(agentId, username, updates)` - Сохранить изменения
- `resetHandoverStatus(agentId, username)` - Очистить состояние ожидания
- `getAllDialogs(agentId)` - Получить все разговоры

**Формат ключа хранилища:** `{agentId}_{username}`

### 6. src/modules/send.js (Доставка сообщений)
**Назначение:** Отправка сообщений с человекоподобными задержками

**Особенности:**
- Случайная задержка: 1000-3000мс (настраивается)
- Симуляция индикатора набора
- Отслеживание типа сообщения (OUTGOING vs REPLY)

### 7. src/utils/logger.js (Логирование)
**Назначение:** Структурированное логирование на основе Winston

**Выходы:**
- Консоль: Цветные логи с временными метками
- Файл: `app.log` (все уровни)

**Уровни:** error, warn, info, debug

---

## Общие задачи разработки

### Добавление нового агента

1. **Создайте агента в Supabase:**
```sql
INSERT INTO ai_agents (id, agent_name, tg_session_string, initial_opener_text, client_id, core_system_prompt, agent_persona)
VALUES (
  gen_random_uuid(),
  'Имя агента',
  '', -- Будет заполнено после аутентификации
  'Здравствуйте! Я...',
  '<client_uuid>',
  'Вы...',
  'Профессиональный, дружелюбный...'
);
```

2. **Обновите index.js:20:**
```javascript
const CURRENT_AGENT_UUID = "<новый_uuid_агента>";
```

3. **Аутентифицируйте Telegram-сессию:**
- Удалите старую сессию из БД или установите пустую строку
- Запустите `node index.js` и следуйте инструкциям аутентификации
- Сессия будет автоматически сохранена в базе данных

### Добавление знаний в RAG

1. **Добавьте контент в knowledge/referendum.txt** (или создайте новый .txt файл)

2. **Запустите скрипт эмбеддинга:**
```bash
node scripts/embedKnowledge.js
```

3. **Поведение скрипта:**
- Разбивает текст на сегменты ~500 символов
- Генерирует эмбеддинги с использованием OpenAI
- Сохраняет в таблицу `knowledge_base` с `client_id`

4. **Проверка:**
- Проверьте таблицу Supabase `knowledge_base`
- AI-агент автоматически будет использовать новые знания

### Создание тестовой кампании

```bash
node scripts/addTestLead.js
```

**Что делает:**
- Создает тестовую кампанию в Supabase
- Добавляет тестового лида с username `ilmanEl`
- Связывает с текущим UUID агента
- Статус: `NEW` (готов к контакту)

### Изменение поведения AI

**Вариант 1: Обновить промпты агента в базе данных**
```sql
UPDATE ai_agents
SET
  core_system_prompt = 'Новые инструкции...',
  agent_persona = 'Новая личность...'
WHERE id = '8435c742-1f1e-4e72-a33b-2221985e9f83';
```

**Вариант 2: Изменить логику aiAgent.js**
- Расположение: src/modules/aiAgent.js
- Редактировать конструкцию промпта (строки варьируются)
- Обновить логику определения передачи

**Вариант 3: Настроить модель/параметры**
- Модель: src/config/env.js:37
- Temperature/max_tokens: src/modules/aiAgent.js (в вызове OpenAI API)

### Изменение ограничений скорости

**Расположение:** src/config/env.js:51-54

```javascript
rateLimit: {
  replyDelayMinMs: 2000,  // Изменить минимальную задержку
  replyDelayMaxMs: 5000   // Изменить максимальную задержку
}
```

### Отладка

**Включить подробное логирование:**
- Проверьте `app.log` для полных логов
- Консоль показывает цветной вывод
- Используйте `log.debug()` для дополнительной информации

**Распространенные проблемы:**
- **"Не удалось загрузить данные агента"** - Проверьте существование UUID агента в БД
- **Ошибки сессии** - Повторно аутентифицируйтесь (очистите сессию в БД)
- **Ограничения API** - Настройте задержки или проверьте квоты API
- **Сбой векторного поиска** - Убедитесь, что эмбеддинги существуют в knowledge_base

---

## Рабочий процесс разработки

### Начальная настройка

```bash
# 1. Клонировать репозиторий
git clone <repo_url>
cd Ai-agent

# 2. Установить зависимости
npm install

# 3. Создать файл .env
cat > .env << EOF
TG_API_ID=<ваше_значение>
TG_API_HASH=<ваше_значение>
TG_PHONE=<ваше_значение>
OPENAI_API_KEY=<ваше_значение>
SUPABASE_URL=<ваше_значение>
SUPABASE_KEY=<ваше_значение>
CONTROL_BOT_TOKEN=<ваше_значение>
CONTROL_SECRET_KEY=<ваше_значение>
CONTROL_ADMIN_ID=<ваше_значение>
EOF

# 4. Создать агента в Supabase (см. выше)

# 5. Запустить приложение
node index.js
```

### Рабочий процесс Git

**Текущая ветка:** `claude/claude-md-mhxvfyvwy447qo17-01LDLwRXgznvzveUNJ9mdHyd`

**Соглашение о наименовании веток:**
- Функциональные ветки: `claude/<описание>-<session_id>`
- Должны начинаться с `claude/` и заканчиваться идентификатором сессии
- Сбой push (403) указывает на неправильное имя ветки

**Рекомендации по коммитам:**
- Описательные сообщения в настоящем времени
- Недавний паттерн: "Update <file>.js"
- Держите коммиты сфокусированными на одном изменении

### Тестирование

**В настоящее время не существует автоматизированного фреймворка тестирования.**

**Подход к ручному тестированию:**
1. Создать тестового лида: `node scripts/addTestLead.js`
2. Запустить приложение: `node index.js`
3. Отправить тестовые сообщения с тестового аккаунта
4. Мониторить логи в консоли и `app.log`
5. Проверить состояние в `dialog_state.json`
6. Тестировать процесс одобрения/отклонения контрольного бота

**Рекомендуемые тестовые сценарии:**
- ✓ Охват нового лида
- ✓ Обработка ответа пользователя
- ✓ Генерация AI-ответа
- ✓ Запуск передачи
- ✓ Одобрение контрольного бота
- ✓ Отклонение контрольного бота
- ✓ Редактирование контрольного бота
- ✓ Получение контекста RAG
- ✓ Обновления статуса в базе данных

---

## Соглашения о коде

### Соглашения об именовании

**Переменные:**
- camelCase: `agentData`, `userReply`, `targetUsername`
- Константы: UPPER_SNAKE_CASE: `CURRENT_AGENT_UUID`

**Функции:**
- camelCase: `sendMessage()`, `getDialogState()`
- Асинхронные функции: Всегда используйте паттерн `async/await`

**Файлы:**
- camelCase: `aiAgent.js`, `dialogState.js`
- Конфигурация: lowercase: `env.js`, `logger.js`

### Стиль кода

**Импорты:**
```javascript
// Именованные импорты
import { function1, function2 } from './module.js';

// Импорты по умолчанию
import defaultExport from './module.js';

// Всегда включайте расширение .js
```

**Обработка ошибок:**
```javascript
// Логировать ошибки, не выбрасывать в обработчиках событий
try {
  await someOperation();
} catch (e) {
  log.error('Operation failed', e);
}
```

**Логирование:**
```javascript
log.info('Сообщение с контекстом', { data });
log.warn('Предупреждающее сообщение');
log.error('Сообщение об ошибке', error);
```

### Паттерны API

**Telegram API:**
```javascript
// Отправить сообщение
await client.sendMessage(target, { message: text });

// Вызвать метод API
await client.invoke(new Api.messages.ReadHistory({ peer }));
```

**OpenAI API:**
```javascript
const response = await openai.chat.completions.create({
  model: 'gpt-4o-mini',
  messages: history,
  temperature: 0.7,
  max_tokens: 500
});
```

**Supabase:**
```javascript
// Запрос
const { data, error } = await supabase
  .from('table')
  .select('*')
  .eq('field', value);

// RPC функция
const { data, error } = await supabase
  .rpc('function_name', { params });
```

---

## Важные ограничения и подводные камни

### 1. Управление Telegram-сессией
- Строка сессии хранится в базе данных, не в .env
- Если сессия истекает, нужно повторно аутентифицироваться
- Аутентификация интерактивная (требуется код из Telegram)

### 2. UUID агента захардкожен
- **Строка:** index.js:20
- Необходимо обновлять вручную для переключения агентов
- Рассмотрите параметризацию в будущем (переменная env или аргумент CLI)

### 3. Опечатка в названии модели
- Конфигурация показывает `gpt-5-mini` (src/config/env.js:37)
- Вероятно должно быть `gpt-4o-mini`
- Проверьте перед выполнением вызовов OpenAI API

### 4. Управление состоянием
- Состояние диалога - локальный JSON (не в базе данных)
- Потеря `dialog_state.json` = потеря истории разговоров
- Состояние контроля в `control_state.json` (смещение опроса)
- Оба файла игнорируются git

### 5. Ограничение скорости
- Искусственные задержки: 1000-3000мс между сообщениями
- Нет логики повтора при сбоях Telegram API
- OpenAI API имеет собственные ограничения скорости

### 6. Обработка ошибок
- Многие ошибки логируются, но не выбрасываются
- Обработчики событий ловят ошибки для предотвращения сбоев
- Проверяйте логи на наличие скрытых сбоев

### 7. Именование веток для Git
- Должны начинаться с `claude/`
- Должны заканчиваться идентификатором сессии
- Ошибка 403 при push = неправильное имя ветки

### 8. Фильтрация базы знаний
- RAG использует `client_id` для фильтрации
- Убедитесь, что `client_id` агента совпадает с записями знаний
- Порог сходства захардкожен в aiAgent.js

### 9. Логика передачи
- Срабатывает только на конкретных намерениях
- После PENDING_HANDOVER бот игнорирует новые сообщения пользователя
- Необходимо сбросить через действие контрольного бота

### 10. Захардкоженная тестовая цель
- `@ilmanEl` в src/config/env.js:50
- Всегда отслеживается независимо от статуса кампании
- Рассмотрите удаление для продакшена

---

## Соображения безопасности

### API ключи и секреты
- Все хранятся в файле `.env` (игнорируется git)
- Никогда не коммитьте `.env` в систему контроля версий
- Валидируйте все необходимые ключи при запуске

### Telegram сессия
- Строка сессии имеет полный доступ к аккаунту
- Хранится в базе данных (обеспечьте безопасность БД)
- Периодически ротируйте сессии

### Контрольный бот
- Использует `CONTROL_SECRET_KEY` для безопасности
- `CONTROL_ADMIN_ID` ограничивает доступ
- Рассмотрите добавление аутентификации для callback'ов кнопок

### Доступ к базе данных
- Использует сервисный ключ Supabase (полный доступ)
- Нет безопасности на уровне строк в текущей реализации
- Рассмотрите добавление RLS политик для мультитенантного использования

### Валидация ввода
- Сообщения пользователей передаются напрямую в AI
- Нет санитизации перед сохранением
- Рассмотрите защиту от XSS если отображается в веб-интерфейсе

---

## Соображения по производительности

### Узкие места
1. **Вызовы OpenAI API:** ~1-3с на запрос
2. **Векторный поиск:** Зависит от размера базы знаний
3. **Задержки Telegram сообщений:** Искусственная задержка 1-3с

### Возможности оптимизации
1. **Кэширование AI-ответов:** Для общих вопросов
2. **Параллельная обработка:** Обрабатывать несколько диалогов одновременно
3. **Индексы базы данных:** Обеспечить индексы на `username`, `status`, `campaign_id`
4. **Пакетные операции:** Группировать обновления базы данных

### Заметки о масштабируемости
- Текущая архитектура: Один агент, один процесс
- Мульти-агент: Требуются отдельные процессы или пул воркеров
- Общее состояние: Переместить `dialog_state.json` в базу данных
- Большой объем: Рассмотрите очередь сообщений (Redis, RabbitMQ)

---

## Будущие улучшения

### Рекомендуемые доработки

1. **Фреймворк тестирования**
   - Добавить Jest или Mocha для unit-тестов
   - Мокировать Telegram/OpenAI API
   - Интеграционные тесты для полного потока

2. **Управление конфигурацией**
   - Переместить захардкоженные значения в .env или конфигурационный файл
   - Поддержка нескольких агентов через аргументы CLI
   - Динамическая перезагрузка конфигураций агента

3. **Управление состоянием**
   - Мигрировать `dialog_state.json` в Supabase
   - Добавить архивирование разговоров
   - Реализовать очистку состояния для старых разговоров

4. **Обработка ошибок**
   - Добавить логику повтора при сбоях API
   - Реализовать автоматические выключатели
   - Улучшить отчетность об ошибках для администратора

5. **Мониторинг**
   - Сбор метрик (время ответа, показатели успеха)
   - Оповещение о сбоях
   - Дашборд для прогресса кампании

6. **Безопасность**
   - Добавить ограничение скорости на пользователя
   - Реализовать санитизацию ввода
   - Добавить аутентификацию для callback'ов контрольного бота
   - Безопасность на уровне строк в Supabase

7. **Функции**
   - Поддержка нескольких языков
   - Запланированные сообщения
   - A/B тестирование приветственных сообщений
   - Аналитика и отчетность

---

## Ключевые файлы для изменения при общих задачах

| Задача | Файлы для изменения |
|------|----------------|
| **Изменить поведение AI** | src/modules/aiAgent.js, таблица ai_agents |
| **Изменить поток сообщений** | index.js (обработчик событий), src/services/dialog.js |
| **Обновить схему базы данных** | SQL миграции, src/modules/db.js |
| **Добавить новую переменную окружения** | src/config/env.js (валидация), .env |
| **Изменить логирование** | src/utils/logger.js |
| **Изменить контрольный бот** | src/modules/controlBot.js |
| **Обновить логику кампании** | src/services/campaignManager.js |
| **Изменить задержки сообщений** | src/config/env.js, src/modules/send.js |
| **Добавить контент знаний** | knowledge/*.txt, запустить embedKnowledge.js |
| **Переключить агентов** | index.js:20 (CURRENT_AGENT_UUID) |

---

## Руководство по устранению неполадок

### Приложение не запускается

**Ошибка:** "Invalid required env"
- **Причина:** Отсутствующие или недействительные переменные окружения
- **Исправление:** Проверьте файл .env на соответствие списку необходимых переменных
- **Проверка:** src/config/env.js показывает, какие переменные не прошли валидацию

**Ошибка:** "Не удалось загрузить данные агента"
- **Причина:** UUID агента не существует в базе данных
- **Исправление:**
  1. Проверьте index.js:20 на правильность UUID
  2. Убедитесь, что агент существует в таблице `ai_agents`
  3. Убедитесь, что подключение к базе данных работает

**Ошибка:** "Session expired"
- **Причина:** Telegram сессия недействительна
- **Исправление:**
  1. Установите `tg_session_string` в пустую строку в базе данных
  2. Запустите `node index.js` и следуйте инструкциям аутентификации
  3. Новая сессия будет сохранена автоматически

### Сообщения не отправляются

**Симптом:** Бот не отвечает на сообщения
- **Проверьте:** Username находится в массиве `monitoredTargets`?
- **Проверьте:** Статус диалога `PENDING_HANDOVER`?
- **Проверьте:** Логи в `app.log` на наличие ошибок
- **Убедитесь:** Telegram-клиент подключен (проверьте логи запуска)

**Симптом:** AI генерирует ответ, но сообщение не отправлено
- **Проверьте:** Логи src/modules/send.js
- **Проверьте:** Ограничения Telegram API
- **Убедитесь:** Формат username (должен включать @)

### Проблемы с контрольным ботом

**Симптом:** Уведомления не получены
- **Проверьте:** CONTROL_BOT_TOKEN действителен
- **Проверьте:** CONTROL_ADMIN_ID соответствует вашему Telegram ID
- **Проверьте:** Логи src/modules/controlBot.js
- **Убедитесь:** У бота есть разрешение отправлять вам сообщения

**Симптом:** Кнопки не работают
- **Проверьте:** Контрольный бот запущен (startControlBotListener вызван)
- **Проверьте:** Формат данных callback соответствует ожидаемому паттерну
- **Проверьте:** dialog_state.json имеет корректный pending_reply

### RAG не работает

**Симптом:** AI не использует базу знаний
- **Проверьте:** Таблица knowledge_base содержит записи
- **Проверьте:** client_id совпадает между агентом и знаниями
- **Проверьте:** Порог сходства в aiAgent.js
- **Убедитесь:** Эмбеддинги были корректно сгенерированы

**Исправление:** Повторно запустите скрипт эмбеддинга
```bash
node scripts/embedKnowledge.js
```

### Ошибки базы данных

**Симптом:** "relation 'table_name' does not exist"
- **Причина:** Отсутствует таблица базы данных
- **Исправление:** Запустите SQL миграции для создания необходимых таблиц

**Симптом:** "RPC function does not exist"
- **Причина:** Отсутствует функция `match_knowledge`
- **Исправление:** Создайте функцию векторного поиска в Supabase

---

## Рекомендации для AI-ассистентов

При работе с этой кодовой базой следуйте этим рекомендациям:

### Что делать
✓ Читать соответствующие исходные файлы перед внесением изменений
✓ Тестировать изменения с помощью `node scripts/addTestLead.js` и ручного тестирования
✓ Проверять логи в `app.log` для отладки
✓ Аккуратно обновлять запросы к базе данных (Supabase)
✓ Поддерживать существующий стиль кода и соглашения
✓ Документировать новые функции или сложную логику
✓ Использовать async/await для всех асинхронных операций
✓ Логировать важные события с winston logger
✓ Учитывать влияние на управление состоянием диалога
✓ Тестировать как обычный поток, так и поток передачи

### Чего не делать
✗ Не коммитьте файлы `.env`, `*.log` или `*_state.json`
✗ Не изменяйте UUID агента без обновления базы данных
✗ Не удаляйте обработку ошибок из обработчиков событий
✗ Не захардкоживайте API ключи или учетные данные
✗ Не изменяйте файлы состояния вручную (используйте предоставленные функции)
✗ Не пропускайте валидацию переменных окружения
✗ Не используйте callback'и (предпочитайте async/await)
✗ Не выбрасывайте ошибки в обработчиках событий Telegram
✗ Не забывайте расширение `.js` в импортах
✗ Не пушьте в ветки, не начинающиеся с `claude/`

### Перед внесением изменений
1. Понять полный поток сообщений
2. Проверить, влияет ли изменение на состояние диалога
3. Рассмотреть влияние на статус кампании
4. Убедиться, что изменение не нарушает контрольный бот
5. Протестировать с активным состоянием и состоянием ожидания передачи

### После внесения изменений
1. Тестировать с тестовым лидом
2. Проверить, что логи показывают ожидаемое поведение
3. Проверить dialog_state.json на корректные обновления
4. Подтвердить обновления базы данных (если применимо)
5. Протестировать поток контрольного бота (если затронут)
6. Проверить обработку ошибок

---

## Краткая справка

### Запустить приложение
```bash
node index.js
```

### Создать тестовые данные
```bash
node scripts/addTestLead.js
```

### Эмбеддинг знаний
```bash
node scripts/embedKnowledge.js
```

### Просмотр логов
```bash
tail -f app.log
```

### Проверить состояние
```bash
cat dialog_state.json | jq
cat control_state.json | jq
```

### Git операции
```bash
# Создать и переключиться на ветку claude
git checkout -b claude/<описание>-<session_id>

# Закоммитить изменения
git add .
git commit -m "Описание"

# Запушить на удаленный репозиторий
git push -u origin claude/<имя_ветки>
```

---

## Ресурсы

### Документация
- Telegram API: https://core.telegram.org/api
- Библиотека Telegram: https://gram.js.org/
- OpenAI API: https://platform.openai.com/docs
- Документация Supabase: https://supabase.com/docs
- Winston Logging: https://github.com/winstonjs/winston

### Внутренние файлы
- Конфигурация окружения: src/config/env.js
- Основной поток: index.js
- Логика AI: src/modules/aiAgent.js
- Контрольный бот: src/modules/controlBot.js
- Управление состоянием: src/services/dialogState.js

### Поддержка
- Проверяйте логи: `app.log`
- Просматривайте комментарии кода (смешанные английский/русский)
- Тестируйте с: `scripts/addTestLead.js`

---

## Резюме

Это событийно-управляемый Telegram-бот агент, который:
1. Отправляет начальные сообщения лидам кампаний
2. Использует AI (GPT-4o-mini) с RAG для умных ответов
3. Определяет, когда нужно передать администратору-человеку
4. Предоставляет интерфейс контрольного бота для одобрения сообщений
5. Отслеживает прогресс кампании в Supabase

**Ключевой принцип:** Бот должен ощущаться человекоподобным (задержки, индикаторы набора), сохраняя эффективность AI.

**Особенность архитектуры:** Гибридное управление состоянием (БД для кампаний/лидов, JSON для истории диалогов) обеспечивает быстрый локальный доступ с постоянным хранением.

**Человек в цикле:** Контрольный бот обеспечивает качество перед отправкой критических сообщений, поддерживая репутацию и качество отношений.

---

*Последнее обновление: 2025-11-13*
*Репозиторий: /home/user/Ai-agent*
*Версия: 1.0.0*
